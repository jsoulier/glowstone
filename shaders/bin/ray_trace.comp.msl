#include <metal_stdlib>
#include <simd/simd.h>

using namespace metal;

struct CameraState
{
    packed_float3 Position;
    float AspectRatio;
    packed_float3 Forward;
    float TanHalfFov;
    packed_float3 Right;
    float Padding1;
    packed_float3 Up;
    float Padding2;
    float4x4 Matrix3D;
};

struct type_StructuredBuffer_CameraState
{
    CameraState _m0[1];
};

struct WorldState
{
    int2 Position;
};

struct type_StructuredBuffer_WorldState
{
    WorldState _m0[1];
};

struct BlockState
{
    uint Color;
};

struct type_StructuredBuffer_BlockState
{
    BlockState _m0[1];
};

constant float4 _340 = {};

kernel void main0(const device type_StructuredBuffer_CameraState& cameraState [[buffer(0)]], const device type_StructuredBuffer_WorldState& worldState [[buffer(1)]], const device type_StructuredBuffer_BlockState& blockState [[buffer(2)]], texture3d<uint> blockTexture [[texture(0)]], texture2d<uint> chunkTexture [[texture(1)]], texture2d<float, access::write> outTexture [[texture(2)]], uint3 gl_GlobalInvocationID [[thread_position_in_grid]])
{
    do
    {
        uint2 _359 = uint2(outTexture.get_width(), outTexture.get_height());
        uint _361 = _359.x;
        uint _365 = _359.y;
        bool _387;
        if (!(gl_GlobalInvocationID.x >= _361))
        {
            _387 = gl_GlobalInvocationID.y >= _365;
        }
        else
        {
            _387 = true;
        }
        if (_387)
        {
            break;
        }
        float3 _462 = fast::normalize(((float3(cameraState._m0[0u].Right) * (((((2.0 * (float(gl_GlobalInvocationID.x) + 0.5)) / float(_361)) - 1.0) * cameraState._m0[0u].AspectRatio) * cameraState._m0[0u].TanHalfFov)) - (float3(cameraState._m0[0u].Up) * ((1.0 - ((2.0 * (float(gl_GlobalInvocationID.y) + 0.5)) / float(_365))) * cameraState._m0[0u].TanHalfFov))) + float3(cameraState._m0[0u].Forward));
        float3 _342 = _462;
        float3 _343 = float3(cameraState._m0[0u].Position);
        int3 _344 = int3(floor(float3(cameraState._m0[0u].Position)));
        float3 _345 = abs(float3(1.0) / _462);
        int3 _346;
        float3 _347;
        for (int _495 = 0; _495 < 3; _495++)
        {
            uint _506 = uint(_495);
            if (_342[_506] < 0.0)
            {
                _346[_506] = -1;
                _347[_506] = (_343[_506] - float(_344[_506])) * _345[_506];
            }
            else
            {
                _346[_506] = 1;
                _347[_506] = ((float(_344[_506]) + 1.0) - _343[_506]) * _345[_506];
            }
        }
        uint _585;
        uint _865;
        int _581 = 0;
        uint _584 = 0u;
        for (;;)
        {
            if (_581 < 512)
            {
                int3 _595 = _344;
                int _607 = _595.x - (((device int*)&worldState._m0[0u].Position)[0] * 32);
                int3 _609 = _595;
                _609.x = _607;
                int _621 = _595.z - (((device int*)&worldState._m0[0u].Position)[1] * 32);
                _609.z = _621;
                int2 _629 = _609.xz / int2(32);
                bool _643;
                if (!(_607 < 0))
                {
                    _643 = _621 < 0;
                }
                else
                {
                    _643 = true;
                }
                bool _655;
                if (!_643)
                {
                    _655 = _629.x >= 8;
                }
                else
                {
                    _655 = true;
                }
                bool _667;
                if (!_655)
                {
                    _667 = _629.y >= 8;
                }
                else
                {
                    _667 = true;
                }
                if (_667)
                {
                    _865 = _584;
                    break;
                }
                int2 _694 = int2(chunkTexture.read(uint2(uint2(_629)), 0u).xy);
                int3 _704 = _609;
                _704.x = (_607 - (_629.x * 32)) + (_694.x * 32);
                _704.z = (_621 - (_629.y * 32)) + (_694.y * 32);
                _585 = blockTexture.read(uint3(uint3(_704)), 0u).x;
                if (_585 != 0u)
                {
                    _865 = _585;
                    break;
                }
                if (_347.x < _347.y)
                {
                    if (_347.x < _347.z)
                    {
                        _347.x += _345.x;
                        _344.x += _346.x;
                    }
                    else
                    {
                        _347.z += _345.z;
                        _344.z += _346.z;
                    }
                }
                else
                {
                    if (_347.y < _347.z)
                    {
                        _347.y += _345.y;
                        _344.y += _346.y;
                    }
                    else
                    {
                        _347.z += _345.z;
                        _344.z += _346.z;
                    }
                }
                _581++;
                _584 = _585;
                continue;
            }
            else
            {
                _865 = _584;
                break;
            }
        }
        outTexture.write(float4(float((blockState._m0[_865].Color >> 24u) & 255u) * 0.0039215688593685626983642578125, float((blockState._m0[_865].Color >> 16u) & 255u) * 0.0039215688593685626983642578125, float((blockState._m0[_865].Color >> 8u) & 255u) * 0.0039215688593685626983642578125, float(blockState._m0[_865].Color & 255u) * 0.0039215688593685626983642578125), uint2(gl_GlobalInvocationID.xy));
        break;
    } while(false);
}

