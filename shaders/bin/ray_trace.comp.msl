#include <metal_stdlib>
#include <simd/simd.h>

using namespace metal;

struct CameraState
{
    packed_float3 Position;
    float AspectRatio;
    packed_float3 Forward;
    float TanHalfFov;
    packed_float3 Right;
    float Padding1;
    packed_float3 Up;
    float Padding2;
};

struct type_StructuredBuffer_CameraState
{
    CameraState _m0[1];
};

struct WorldState
{
    int2 Position;
};

struct type_StructuredBuffer_WorldState
{
    WorldState _m0[1];
};

kernel void main0(const device type_StructuredBuffer_CameraState& cameraState [[buffer(0)]], texture3d<uint> blocks [[texture(0)]], texture2d<float, access::write> outTexture [[texture(2)]], uint3 gl_GlobalInvocationID [[thread_position_in_grid]])
{
    do
    {
        uint2 _74 = uint2(outTexture.get_width(), outTexture.get_height());
        uint _75 = _74.x;
        uint _76 = _74.y;
        bool _86;
        if (!(gl_GlobalInvocationID.x >= _75))
        {
            _86 = gl_GlobalInvocationID.y >= _76;
        }
        else
        {
            _86 = true;
        }
        if (_86)
        {
            break;
        }
        float3 _121 = fast::normalize(((float3(cameraState._m0[0u].Right) * (((((2.0 * (float(gl_GlobalInvocationID.x) + 0.5)) / float(_75)) - 1.0) * cameraState._m0[0u].AspectRatio) * cameraState._m0[0u].TanHalfFov)) - (float3(cameraState._m0[0u].Up) * ((1.0 - ((2.0 * (float(gl_GlobalInvocationID.y) + 0.5)) / float(_76))) * cameraState._m0[0u].TanHalfFov))) + float3(cameraState._m0[0u].Forward));
        float3 _63 = _121;
        float3 _64 = float3(cameraState._m0[0u].Position);
        int3 _65 = int3(floor(float3(cameraState._m0[0u].Position)));
        float3 _66 = abs(float3(1.0) / _121);
        int3 _67;
        float3 _68;
        for (int _129 = 0; _129 < 3; _129++)
        {
            uint _135 = uint(_129);
            if (_63[_135] < 0.0)
            {
                _67[_135] = -1;
                _68[_135] = (_64[_135] - float(_65[_135])) * _66[_135];
            }
            else
            {
                _67[_135] = 1;
                _68[_135] = ((float(_65[_135]) + 1.0) - _64[_135]) * _66[_135];
            }
        }
        uint _170;
        uint _239;
        int _166 = 0;
        uint _169 = 0u;
        for (;;)
        {
            if (_166 < 512)
            {
                _170 = blocks.read(uint3(uint3(_65)), 0u).x;
                if (_170 != 0u)
                {
                    _239 = _170;
                    break;
                }
                if (_68.x < _68.y)
                {
                    if (_68.x < _68.z)
                    {
                        _68.x += _66.x;
                        _65.x += _67.x;
                    }
                    else
                    {
                        _68.z += _66.z;
                        _65.z += _67.z;
                    }
                }
                else
                {
                    if (_68.y < _68.z)
                    {
                        _68.y += _66.y;
                        _65.y += _67.y;
                    }
                    else
                    {
                        _68.z += _66.z;
                        _65.z += _67.z;
                    }
                }
                _166++;
                _169 = _170;
                continue;
            }
            else
            {
                _239 = _169;
                break;
            }
        }
        if (_239 != 0u)
        {
            float4 _69 = float4(0.0, 0.0, 0.0, 1.0);
            _69[uint(_65.y - 3 * (_65.y / 3))] = 1.0;
            outTexture.write(_69, uint2(gl_GlobalInvocationID.xy));
        }
        else
        {
            outTexture.write(float4(0.0), uint2(gl_GlobalInvocationID.xy));
        }
        break;
    } while(false);
}

