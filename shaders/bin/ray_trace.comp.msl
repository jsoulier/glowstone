#include <metal_stdlib>
#include <simd/simd.h>

using namespace metal;

struct CameraState
{
    packed_float3 Position;
    float AspectRatio;
    packed_float3 Forward;
    float TanHalfFov;
    packed_float3 Right;
    float Padding1;
    packed_float3 Up;
    float Padding2;
};

struct type_StructuredBuffer_CameraState
{
    CameraState _m0[1];
};

struct WorldState
{
    int2 Position;
};

struct type_StructuredBuffer_WorldState
{
    WorldState _m0[1];
};

kernel void main0(const device type_StructuredBuffer_CameraState& cameraState [[buffer(0)]], const device type_StructuredBuffer_WorldState& worldState [[buffer(1)]], texture3d<uint> blocks [[texture(0)]], texture2d<uint> chunks [[texture(1)]], texture2d<float, access::write> outTexture [[texture(2)]], uint3 gl_GlobalInvocationID [[thread_position_in_grid]])
{
    do
    {
        uint2 _339 = uint2(outTexture.get_width(), outTexture.get_height());
        uint _341 = _339.x;
        uint _345 = _339.y;
        bool _367;
        if (!(gl_GlobalInvocationID.x >= _341))
        {
            _367 = gl_GlobalInvocationID.y >= _345;
        }
        else
        {
            _367 = true;
        }
        if (_367)
        {
            break;
        }
        float3 _442 = fast::normalize(((float3(cameraState._m0[0u].Right) * (((((2.0 * (float(gl_GlobalInvocationID.x) + 0.5)) / float(_341)) - 1.0) * cameraState._m0[0u].AspectRatio) * cameraState._m0[0u].TanHalfFov)) - (float3(cameraState._m0[0u].Up) * ((1.0 - ((2.0 * (float(gl_GlobalInvocationID.y) + 0.5)) / float(_345))) * cameraState._m0[0u].TanHalfFov))) + float3(cameraState._m0[0u].Forward));
        float3 _321 = _442;
        float3 _322 = float3(cameraState._m0[0u].Position);
        int3 _323 = int3(floor(float3(cameraState._m0[0u].Position)));
        float3 _324 = abs(float3(1.0) / _442);
        int3 _325;
        float3 _326;
        for (int _475 = 0; _475 < 3; _475++)
        {
            uint _486 = uint(_475);
            if (_321[_486] < 0.0)
            {
                _325[_486] = -1;
                _326[_486] = (_322[_486] - float(_323[_486])) * _324[_486];
            }
            else
            {
                _325[_486] = 1;
                _326[_486] = ((float(_323[_486]) + 1.0) - _322[_486]) * _324[_486];
            }
        }
        uint _565;
        uint _845;
        int _561 = 0;
        uint _564 = 0u;
        for (;;)
        {
            if (_561 < 512)
            {
                int3 _575 = _323;
                int _587 = _575.x - (((device int*)&worldState._m0[0u].Position)[0] * 32);
                int3 _589 = _575;
                _589.x = _587;
                int _601 = _575.z - (((device int*)&worldState._m0[0u].Position)[1] * 32);
                _589.z = _601;
                int2 _609 = _589.xz / int2(32);
                bool _623;
                if (!(_587 < 0))
                {
                    _623 = _601 < 0;
                }
                else
                {
                    _623 = true;
                }
                bool _635;
                if (!_623)
                {
                    _635 = _609.x >= 2;
                }
                else
                {
                    _635 = true;
                }
                bool _647;
                if (!_635)
                {
                    _647 = _609.y >= 2;
                }
                else
                {
                    _647 = true;
                }
                if (_647)
                {
                    _845 = _564;
                    break;
                }
                int2 _674 = int2(chunks.read(uint2(uint2(_609)), 0u).xy);
                int3 _684 = _589;
                _684.x = (_587 - (_609.x * 32)) + (_674.x * 32);
                _684.z = (_601 - (_609.y * 32)) + (_674.y * 32);
                _565 = blocks.read(uint3(uint3(_684)), 0u).x;
                if (_565 != 0u)
                {
                    _845 = _565;
                    break;
                }
                if (_326.x < _326.y)
                {
                    if (_326.x < _326.z)
                    {
                        _326.x += _324.x;
                        _323.x += _325.x;
                    }
                    else
                    {
                        _326.z += _324.z;
                        _323.z += _325.z;
                    }
                }
                else
                {
                    if (_326.y < _326.z)
                    {
                        _326.y += _324.y;
                        _323.y += _325.y;
                    }
                    else
                    {
                        _326.z += _324.z;
                        _323.z += _325.z;
                    }
                }
                _561++;
                _564 = _565;
                continue;
            }
            else
            {
                _845 = _564;
                break;
            }
        }
        if (_845 != 0u)
        {
            float4 _327 = float4(0.0, 0.0, 0.0, 1.0);
            _327[uint(_323.y - 3 * (_323.y / 3))] = 1.0;
            outTexture.write(_327, uint2(gl_GlobalInvocationID.xy));
        }
        else
        {
            outTexture.write(float4(0.0), uint2(gl_GlobalInvocationID.xy));
        }
        break;
    } while(false);
}

