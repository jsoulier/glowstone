#include <metal_stdlib>
#include <simd/simd.h>

using namespace metal;

struct CameraState
{
    packed_float3 Position;
    float AspectRatio;
    packed_float3 Forward;
    float TanHalfFov;
    packed_float3 Right;
    float Padding1;
    packed_float3 Up;
    float Padding2;
};

struct type_StructuredBuffer_CameraState
{
    CameraState _m0[1];
};

struct WorldState
{
    int2 Position;
};

struct type_StructuredBuffer_WorldState
{
    WorldState _m0[1];
};

struct BlockState
{
    float2 TexCoord;
};

struct type_StructuredBuffer_BlockState
{
    BlockState _m0[1];
};

kernel void main0(const device type_StructuredBuffer_CameraState& cameraState [[buffer(0)]], const device type_StructuredBuffer_WorldState& worldState [[buffer(1)]], texture3d<uint> blocks [[texture(0)]], texture2d<uint> chunks [[texture(1)]], texture2d<float, access::write> outTexture [[texture(2)]], uint3 gl_GlobalInvocationID [[thread_position_in_grid]])
{
    do
    {
        uint2 _357 = uint2(outTexture.get_width(), outTexture.get_height());
        uint _359 = _357.x;
        uint _363 = _357.y;
        bool _385;
        if (!(gl_GlobalInvocationID.x >= _359))
        {
            _385 = gl_GlobalInvocationID.y >= _363;
        }
        else
        {
            _385 = true;
        }
        if (_385)
        {
            break;
        }
        float3 _460 = fast::normalize(((float3(cameraState._m0[0u].Right) * (((((2.0 * (float(gl_GlobalInvocationID.x) + 0.5)) / float(_359)) - 1.0) * cameraState._m0[0u].AspectRatio) * cameraState._m0[0u].TanHalfFov)) - (float3(cameraState._m0[0u].Up) * ((1.0 - ((2.0 * (float(gl_GlobalInvocationID.y) + 0.5)) / float(_363))) * cameraState._m0[0u].TanHalfFov))) + float3(cameraState._m0[0u].Forward));
        float3 _339 = _460;
        float3 _340 = float3(cameraState._m0[0u].Position);
        int3 _341 = int3(floor(float3(cameraState._m0[0u].Position)));
        float3 _342 = abs(float3(1.0) / _460);
        int3 _343;
        float3 _344;
        for (int _493 = 0; _493 < 3; _493++)
        {
            uint _504 = uint(_493);
            if (_339[_504] < 0.0)
            {
                _343[_504] = -1;
                _344[_504] = (_340[_504] - float(_341[_504])) * _342[_504];
            }
            else
            {
                _343[_504] = 1;
                _344[_504] = ((float(_341[_504]) + 1.0) - _340[_504]) * _342[_504];
            }
        }
        uint _583;
        uint _863;
        int _579 = 0;
        uint _582 = 0u;
        for (;;)
        {
            if (_579 < 512)
            {
                int3 _593 = _341;
                int _605 = _593.x - (((device int*)&worldState._m0[0u].Position)[0] * 32);
                int3 _607 = _593;
                _607.x = _605;
                int _619 = _593.z - (((device int*)&worldState._m0[0u].Position)[1] * 32);
                _607.z = _619;
                int2 _627 = _607.xz / int2(32);
                bool _641;
                if (!(_605 < 0))
                {
                    _641 = _619 < 0;
                }
                else
                {
                    _641 = true;
                }
                bool _653;
                if (!_641)
                {
                    _653 = _627.x >= 8;
                }
                else
                {
                    _653 = true;
                }
                bool _665;
                if (!_653)
                {
                    _665 = _627.y >= 8;
                }
                else
                {
                    _665 = true;
                }
                if (_665)
                {
                    _863 = _582;
                    break;
                }
                int2 _692 = int2(chunks.read(uint2(uint2(_627)), 0u).xy);
                int3 _702 = _607;
                _702.x = (_605 - (_627.x * 32)) + (_692.x * 32);
                _702.z = (_619 - (_627.y * 32)) + (_692.y * 32);
                _583 = blocks.read(uint3(uint3(_702)), 0u).x;
                if (_583 != 0u)
                {
                    _863 = _583;
                    break;
                }
                if (_344.x < _344.y)
                {
                    if (_344.x < _344.z)
                    {
                        _344.x += _342.x;
                        _341.x += _343.x;
                    }
                    else
                    {
                        _344.z += _342.z;
                        _341.z += _343.z;
                    }
                }
                else
                {
                    if (_344.y < _344.z)
                    {
                        _344.y += _342.y;
                        _341.y += _343.y;
                    }
                    else
                    {
                        _344.z += _342.z;
                        _341.z += _343.z;
                    }
                }
                _579++;
                _582 = _583;
                continue;
            }
            else
            {
                _863 = _582;
                break;
            }
        }
        if (_863 != 0u)
        {
            float4 _345 = float4(0.0, 0.0, 0.0, 1.0);
            _345[uint(_341.y - 3 * (_341.y / 3))] = 1.0;
            outTexture.write(_345, uint2(gl_GlobalInvocationID.xy));
        }
        else
        {
            outTexture.write(float4(0.0), uint2(gl_GlobalInvocationID.xy));
        }
        break;
    } while(false);
}

