#include "config.h"
#include "random.hlsl"
#include "shader.hlsl"

#define DEBUG 0

static const int kMaxSteps = 512;
static const int kMaxBounces = 8;
static const float3 kSkyBottom = float3(1.0f, 1.0f, 1.0f);
static const float3 kSkyTop = float3(0.5f, 0.7f, 1.0f);

cbuffer UniformBuffer : register(b0, space2)
{
    int Sample;
};

Texture3D<uint> blockTexture : register(t0, space0);
Texture2D<uint2> chunkTexture : register(t1, space0);
StructuredBuffer<CameraState> cameraState : register(t2, space0);
StructuredBuffer<WorldState> worldState : register(t3, space0);
StructuredBuffer<BlockState> blockState : register(t4, space0);
[[vk::image_format("rgba32f")]]
RWTexture2D<float4> outTexture : register(u0, space1);

struct Query
{
    bool Hit;
    uint Block;
    float3 Position;
    float3 Normal;
};

Query Raycast(float3 origin, float3 direction, float ior)
{
    int3 voxel = int3(floor(origin));
    float3 delta = abs(1.0 / direction);
    int3 step;
    float3 distance;
    int axis = -1;
    for (int i = 0; i < 3; i++)
    {
        if (direction[i] < 0.0f)
        {
            step[i] = -1;
            distance[i] = (origin[i] - voxel[i]) * delta[i];
        }
        else
        {
            step[i] = 1;
            distance[i] = (voxel[i] + 1.0f - origin[i]) * delta[i];
        }
    }
    for (int i = 0; i < kMaxSteps; i++)
    {
        int3 position = voxel;
        position.x -= worldState[0].Position.x * CHUNK_WIDTH;
        position.z -= worldState[0].Position.y * CHUNK_WIDTH;
        int2 chunk = position.xz / CHUNK_WIDTH;
        if (position.x < 0 || position.z < 0 || chunk.x >= WORLD_WIDTH ||
            chunk.y >= WORLD_WIDTH || (step.y > 0 && position.y > CHUNK_HEIGHT))
        {
            break;
        }
        position.x -= chunk.x * CHUNK_WIDTH;
        position.z -= chunk.y * CHUNK_WIDTH;
        chunk = chunkTexture[chunk];
        position.x += chunk.x * CHUNK_WIDTH;
        position.z += chunk.y * CHUNK_WIDTH;
        uint hitBlock = blockTexture[position];
        BlockState block = blockState[hitBlock];
        bool refract = ior > kEpsilon || block.IOR > kEpsilon;
        if ((!refract && hitBlock != kBlockAir) || (refract && abs(block.IOR - ior) > kEpsilon))
        {
            float3 normal = float3(0.0f, 0.0f, 0.0f);
            float t = 0.0f;
            if (axis == 0)
            {
                normal.x = -step.x;
                t = distance.x - delta.x;
            }
            else if (axis == 1)
            {
                normal.y = -step.y;
                t = distance.y - delta.y;
            }
            else if (axis == 2)
            {
                normal.z = -step.z;
                t = distance.z - delta.z;
            }
            else
            {
                // NOTE: don't know why but let's me see underwater
                normal = -direction;
            }
            Query query;
            query.Hit = true;
            query.Block = hitBlock;
            query.Position = origin + direction * t;
            query.Normal = normal;
            return query;
        }
        if (distance.x < distance.y)
        {
            if (distance.x < distance.z)
            {
                distance.x += delta.x;
                voxel.x += step.x;
                axis = 0;
            }
            else
            {
                distance.z += delta.z;
                voxel.z += step.z;
                axis = 2;
            }
        }
        else
        {
            if (distance.y < distance.z)
            {
                distance.y += delta.y;
                voxel.y += step.y;
                axis = 1;
            }
            else
            {
                distance.z += delta.z;
                voxel.z += step.z;
                axis = 2;
            }
        }
    }
    Query query;
    query.Hit = false;
    return query;
}

float FresnelSchlick(float3 direction, float3 normal, float iorFrom, float iorTo)
{
    float cosTheta = saturate(dot(-direction, normal));
    iorFrom += 1.0f;
    iorTo += 1.0f;
    float r0 = (iorFrom - iorTo) / (iorFrom + iorTo);
    r0 = r0 * r0;
    return r0 + (1.0f - r0) * pow(1.0f - cosTheta, 5.0f);
}

[numthreads(RAYTRACE_THREADS_X, RAYTRACE_THREADS_Y, 1)]
void main(uint3 id : SV_DispatchThreadID)
{
    uint width;
    uint height;
    outTexture.GetDimensions(width, height);
    if (id.x >= width || id.y >= height)
    {
        return;
    }
    float i = Random(float4(id.xy, Sample, 0));
    float j = Random(float4(id.xy, Sample, 1));
    float u = (2.0f * (id.x + i) / width - 1.0f) * cameraState[0].AspectRatio * cameraState[0].TanHalfFov;
    float v = (1.0f - 2.0f * (id.y + j) / height) * cameraState[0].TanHalfFov;
    float3 direction = normalize(u * cameraState[0].Right - v * cameraState[0].Up + cameraState[0].Forward);
    float3 origin = cameraState[0].Position;
    float ior = 0.0f;
    float3 radiance = 0.0f;
    float3 throughput = 1.0f;
    for (int bounce = 0; bounce < kMaxBounces; bounce++)
    {
        Query query = Raycast(origin, direction, ior);
        if (!query.Hit)
        {
            radiance += throughput * lerp(kSkyBottom, kSkyTop, saturate((direction.y + 1.0f) / 2.0f));
            break;
        }
#if DEBUG == 0
        BlockState block = blockState[query.Block];
        if (query.Block != kBlockAir)
        {
            float3 albedo;
            albedo.r = float((block.Color >> 24) & 0xFFu) / 255.0f;
            albedo.g = float((block.Color >> 16) & 0xFFu) / 255.0f;
            albedo.b = float((block.Color >> 8) & 0xFFu) / 255.0f;
            float3 emission = albedo * block.Light;
            radiance += throughput * emission;
            throughput *= albedo;
        }
        if (block.IOR > kEpsilon || (ior > kEpsilon && query.Block == kBlockAir))
        {
            if (Random(float4(id.xy, Sample * 11.0f, bounce)) > FresnelSchlick(direction, query.Normal, ior, block.IOR))
            {
                float3 newDirection = refract(direction, query.Normal, (1.0f + ior) / (1.0f + block.IOR));
                if (length(newDirection) > kEpsilon)
                {
                    direction = newDirection;
                    origin = query.Position + direction * 0.001f;
                    ior = block.IOR;
                    continue;
                }
            }
        }
        float3 reflected = reflect(direction, query.Normal);
        float3 diffuse = RandomHemisphere(query.Normal, id.xy, Sample, bounce);
        direction = normalize(lerp(reflected, diffuse, block.Roughness));
        origin = query.Position + query.Normal * 0.001f;
        if (block.Light > kEpsilon)
        {
            break;
        }
#elif DEBUG == 1
        float3 color = 0.0f;
        if (query.Normal.x == 1.0f)
        {
            color = float3(1.0f, 0.0f, 0.0f);
        }
        else if (query.Normal.x == -1.0f)
        {
            color = float3(0.0f, 1.0f, 0.0f);
        }
        else if (query.Normal.y == 1.0f)
        {
            color = float3(0.0f, 0.0f, 1.0f);
        }
        else if (query.Normal.y == -1.0f)
        {
            color = float3(1.0f, 1.0f, 0.0f);
        }
        else if (query.Normal.z == 1.0f)
        {
            color = float3(0.0f, 1.0f, 1.0f);
        }
        else if (query.Normal.z == -1.0f)
        {
            color = float3(1.0f, 0.0f, 1.0f);
        }
        else
        {
            color = float3(1.0f, 1.0f, 1.0f);
        }
        outTexture[id.xy] += float4(color, 1.0f);
        return;
#endif
    }
    outTexture[id.xy] += float4(radiance, 1.0f);
}