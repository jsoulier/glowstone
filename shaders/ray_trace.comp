#include "config.h"
#include "shader.hlsl"

static const int kMaxSteps = 512;

Texture3D<uint> blocks : register(t0, space0);
Texture2D<uint2> chunks : register(t1, space0);
StructuredBuffer<CameraState> cameraState : register(t2, space0);
StructuredBuffer<WorldState> worldState : register(t3, space0);
StructuredBuffer<BlockState> blockState : register(t4, space0);
[[vk::image_format("rgba8")]]
RWTexture2D<float4> outTexture : register(u0, space1);

[numthreads(RAY_TRACE_THREADS_X, RAY_TRACE_THREADS_Y, 1)]
void main(uint3 id : SV_DispatchThreadID)
{
    uint width;
    uint height;
    outTexture.GetDimensions(width, height);
    if (id.x >= width || id.y >= height)
    {
        return;
    }
    float u = (2.0f * (id.x + 0.5f) / width - 1.0f) * cameraState[0].AspectRatio * cameraState[0].TanHalfFov;
    float v = (1.0f - 2.0f * (id.y + 0.5f) / height) * cameraState[0].TanHalfFov;
    float3 direction = normalize(u * cameraState[0].Right - v * cameraState[0].Up + cameraState[0].Forward);
    float3 origin = cameraState[0].Position;
    int3 voxel = int3(floor(origin));
    float3 delta = abs(1.0 / direction);
    int3 step;
    float3 distance;
    for (int i = 0; i < 3; i++)
    {
        if (direction[i] < 0.0f)
        {
            step[i] = -1;
            distance[i] = (origin[i] - voxel[i]) * delta[i];
        }
        else
        {
            step[i] = 1;
            distance[i] = (voxel[i] + 1.0f - origin[i]) * delta[i];
        }
    }
    uint hitBlock = kAir;
    for (int i = 0; i < kMaxSteps; i++)
    {
        int3 position = voxel;
        position.x -= worldState[0].Position.x * CHUNK_WIDTH;
        position.z -= worldState[0].Position.y * CHUNK_WIDTH;
        int2 chunk = position.xz / CHUNK_WIDTH;
        // NOTE: correct, but not required since we handle negatives by checking position.xz < 0 (rather than chunk)
        // int2 chunk = floor(float2(position.xz) / float(CHUNK_WIDTH));
        // if (chunk.x < 0 || chunk.y < 0 || chunk.x >= WORLD_WIDTH || chunk.y >= WORLD_WIDTH)
        // TODO: remove by computing kMaxSteps correctly
        if (position.x < 0 || position.z < 0 || chunk.x >= WORLD_WIDTH || chunk.y >= WORLD_WIDTH)
        {
            break;
        }
        position.x -= chunk.x * CHUNK_WIDTH;
        position.z -= chunk.y * CHUNK_WIDTH;
        chunk = chunks[chunk];
        position.x += chunk.x * CHUNK_WIDTH;
        position.z += chunk.y * CHUNK_WIDTH;
        hitBlock = blocks[position];
        if (hitBlock != kAir)
        {
            break;
        }
        if (distance.x < distance.y)
        {
            if (distance.x < distance.z)
            {
                distance.x += delta.x;
                voxel.x += step.x;
            }
            else
            {
                distance.z += delta.z;
                voxel.z += step.z;
            }
        }
        else
        {
            if (distance.y < distance.z)
            {
                distance.y += delta.y;
                voxel.y += step.y;
            }
            else
            {
                distance.z += delta.z;
                voxel.z += step.z;
            }
        }
    }
    if (hitBlock != kAir)
    {
        float4 color = float4(0.0f, 0.0f, 0.0f, 1.0f);
        color[voxel.y % 3] = 1.0f;
        outTexture[id.xy] = color;
    }
    else
    {
        outTexture[id.xy] = float4(0.0f, 0.0f, 0.0f, 0.0f);
    }
}